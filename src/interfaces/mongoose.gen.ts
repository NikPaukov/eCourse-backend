/* tslint:disable */
/* eslint-disable */

// ######################################## THIS FILE WAS GENERATED BY MONGOOSE-TSGEN ######################################## //

// NOTE: ANY CHANGES MADE WILL BE OVERWRITTEN ON SUBSEQUENT EXECUTIONS OF MONGOOSE-TSGEN.

import mongoose from "mongoose";

/**
 * Lean version of CompanyEmployeeDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `CompanyDocument.toObject()`.
 * ```
 * const companyObject = company.toObject();
 * ```
 */
export type CompanyEmployee = {
  user: User["_id"] | User;
  roles: (Role["_id"] | Role)[];
  isActive?: boolean;
  _id: mongoose.Types.ObjectId;
};

/**
 * Lean version of CompanyDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `CompanyDocument.toObject()`. To avoid conflicts with model names, use the type alias `CompanyObject`.
 * ```
 * const companyObject = company.toObject();
 * ```
 */
export type Company = {
  name: string;
  supportEmail?: string;
  employees: CompanyEmployee[];
  availableRoles: (Role["_id"] | Role)[];
  defaultRole?: Role["_id"] | Role;
  owner: User["_id"] | User;
  isDeleted?: boolean;
  _id: mongoose.Types.ObjectId;
  createdAt?: Date;
  updatedAt?: Date;
};

/**
 * Lean version of CompanyDocument (type alias of `Company`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Company } from "../models"
 * import { CompanyObject } from "../interfaces/mongoose.gen.ts"
 *
 * const companyObject: CompanyObject = company.toObject();
 * ```
 */
export type CompanyObject = Company;

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type CompanyQuery = mongoose.Query<
  any,
  CompanyDocument,
  CompanyQueries
> &
  CompanyQueries;

/**
 * Mongoose Query helper types
 *
 * This type represents `CompanySchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type CompanyQueries = {
  paginate: (this: CompanyQuery, ...args: any[]) => CompanyQuery;
};

export type CompanyMethods = {
  softDelete: (this: CompanyDocument, ...args: any[]) => any;
  restore: (this: CompanyDocument, ...args: any[]) => any;
};

export type CompanyStatics = {
  paginate: (this: CompanyModel, ...args: any[]) => any;
  paginateSubDocs: (this: CompanyModel, ...args: any[]) => any;
};

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Company = mongoose.model<CompanyDocument, CompanyModel>("Company", CompanySchema);
 * ```
 */
export type CompanyModel = mongoose.Model<CompanyDocument, CompanyQueries> &
  CompanyStatics;

/**
 * Mongoose Schema type
 *
 * Assign this type to new Company schema instances:
 * ```
 * const CompanySchema: CompanySchema = new mongoose.Schema({ ... })
 * ```
 */
export type CompanySchema = mongoose.Schema<
  CompanyDocument,
  CompanyModel,
  CompanyMethods,
  CompanyQueries
>;

/**
 * Mongoose Subdocument type
 *
 * Type of `CompanyDocument["employees"]` element.
 */
export type CompanyEmployeeDocument =
  mongoose.Types.Subdocument<mongoose.Types.ObjectId> & {
    user: UserDocument["_id"] | UserDocument;
    roles: mongoose.Types.Array<RoleDocument["_id"] | RoleDocument>;
    isActive?: boolean;
    _id: mongoose.Types.ObjectId;
  };

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Company = mongoose.model<CompanyDocument, CompanyModel>("Company", CompanySchema);
 * ```
 */
export type CompanyDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  CompanyQueries
> &
  CompanyMethods & {
    name: string;
    supportEmail?: string;
    employees: mongoose.Types.DocumentArray<CompanyEmployeeDocument>;
    availableRoles: mongoose.Types.Array<RoleDocument["_id"] | RoleDocument>;
    defaultRole?: RoleDocument["_id"] | RoleDocument;
    owner: UserDocument["_id"] | UserDocument;
    isDeleted?: boolean;
    _id: mongoose.Types.ObjectId;
    createdAt?: Date;
    updatedAt?: Date;
  };

/**
 * Lean version of CourseDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `CourseDocument.toObject()`. To avoid conflicts with model names, use the type alias `CourseObject`.
 * ```
 * const courseObject = course.toObject();
 * ```
 */
export type Course = {
  name: string;
  company: Company["_id"] | Company;
  isPublic: boolean;
  inviteLink?: string;
  modules: (Module["_id"] | Module)[];
  status: "Active" | "Inactive" | "Deleted";
  groups: (Group["_id"] | Group)[];
  isDeleted?: boolean;
  _id: mongoose.Types.ObjectId;
  createdAt?: Date;
  updatedAt?: Date;
};

/**
 * Lean version of CourseDocument (type alias of `Course`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Course } from "../models"
 * import { CourseObject } from "../interfaces/mongoose.gen.ts"
 *
 * const courseObject: CourseObject = course.toObject();
 * ```
 */
export type CourseObject = Course;

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type CourseQuery = mongoose.Query<any, CourseDocument, CourseQueries> &
  CourseQueries;

/**
 * Mongoose Query helper types
 *
 * This type represents `CourseSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type CourseQueries = {
  paginate: (this: CourseQuery, ...args: any[]) => CourseQuery;
};

export type CourseMethods = {
  softDelete: (this: CourseDocument, ...args: any[]) => any;
  restore: (this: CourseDocument, ...args: any[]) => any;
};

export type CourseStatics = {
  paginate: (this: CourseModel, ...args: any[]) => any;
  paginateSubDocs: (this: CourseModel, ...args: any[]) => any;
};

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Course = mongoose.model<CourseDocument, CourseModel>("Course", CourseSchema);
 * ```
 */
export type CourseModel = mongoose.Model<CourseDocument, CourseQueries> &
  CourseStatics;

/**
 * Mongoose Schema type
 *
 * Assign this type to new Course schema instances:
 * ```
 * const CourseSchema: CourseSchema = new mongoose.Schema({ ... })
 * ```
 */
export type CourseSchema = mongoose.Schema<
  CourseDocument,
  CourseModel,
  CourseMethods,
  CourseQueries
>;

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Course = mongoose.model<CourseDocument, CourseModel>("Course", CourseSchema);
 * ```
 */
export type CourseDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  CourseQueries
> &
  CourseMethods & {
    name: string;
    company: CompanyDocument["_id"] | CompanyDocument;
    isPublic: boolean;
    inviteLink?: string;
    modules: mongoose.Types.Array<ModuleDocument["_id"] | ModuleDocument>;
    status: "Active" | "Inactive" | "Deleted";
    groups: mongoose.Types.Array<GroupDocument["_id"] | GroupDocument>;
    isDeleted?: boolean;
    _id: mongoose.Types.ObjectId;
    createdAt?: Date;
    updatedAt?: Date;
  };

/**
 * Lean version of EnrollmentDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `EnrollmentDocument.toObject()`. To avoid conflicts with model names, use the type alias `EnrollmentObject`.
 * ```
 * const enrollmentObject = enrollment.toObject();
 * ```
 */
export type Enrollment = {
  course: Course["_id"] | Course;
  user: User["_id"] | User;
  progress: number;
  isCompleted: boolean;
  group: Group["_id"] | Group;
  certificate?: string;
  completedResources: (Resource["_id"] | Resource)[];
  allowedResources: (Resource["_id"] | Resource)[];
  isDeleted?: boolean;
  _id: mongoose.Types.ObjectId;
  createdAt?: Date;
  updatedAt?: Date;
};

/**
 * Lean version of EnrollmentDocument (type alias of `Enrollment`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Enrollment } from "../models"
 * import { EnrollmentObject } from "../interfaces/mongoose.gen.ts"
 *
 * const enrollmentObject: EnrollmentObject = enrollment.toObject();
 * ```
 */
export type EnrollmentObject = Enrollment;

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type EnrollmentQuery = mongoose.Query<
  any,
  EnrollmentDocument,
  EnrollmentQueries
> &
  EnrollmentQueries;

/**
 * Mongoose Query helper types
 *
 * This type represents `EnrollmentSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type EnrollmentQueries = {
  paginate: (this: EnrollmentQuery, ...args: any[]) => EnrollmentQuery;
};

export type EnrollmentMethods = {
  softDelete: (this: EnrollmentDocument, ...args: any[]) => any;
  restore: (this: EnrollmentDocument, ...args: any[]) => any;
};

export type EnrollmentStatics = {
  paginate: (this: EnrollmentModel, ...args: any[]) => any;
  paginateSubDocs: (this: EnrollmentModel, ...args: any[]) => any;
};

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Enrollment = mongoose.model<EnrollmentDocument, EnrollmentModel>("Enrollment", EnrollmentSchema);
 * ```
 */
export type EnrollmentModel = mongoose.Model<
  EnrollmentDocument,
  EnrollmentQueries
> &
  EnrollmentStatics;

/**
 * Mongoose Schema type
 *
 * Assign this type to new Enrollment schema instances:
 * ```
 * const EnrollmentSchema: EnrollmentSchema = new mongoose.Schema({ ... })
 * ```
 */
export type EnrollmentSchema = mongoose.Schema<
  EnrollmentDocument,
  EnrollmentModel,
  EnrollmentMethods,
  EnrollmentQueries
>;

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Enrollment = mongoose.model<EnrollmentDocument, EnrollmentModel>("Enrollment", EnrollmentSchema);
 * ```
 */
export type EnrollmentDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  EnrollmentQueries
> &
  EnrollmentMethods & {
    course: CourseDocument["_id"] | CourseDocument;
    user: UserDocument["_id"] | UserDocument;
    progress: number;
    isCompleted: boolean;
    group: GroupDocument["_id"] | GroupDocument;
    certificate?: string;
    completedResources: mongoose.Types.Array<
      ResourceDocument["_id"] | ResourceDocument
    >;
    allowedResources: mongoose.Types.Array<
      ResourceDocument["_id"] | ResourceDocument
    >;
    isDeleted?: boolean;
    _id: mongoose.Types.ObjectId;
    createdAt?: Date;
    updatedAt?: Date;
  };

/**
 * Lean version of GroupDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `GroupDocument.toObject()`. To avoid conflicts with model names, use the type alias `GroupObject`.
 * ```
 * const groupObject = group.toObject();
 * ```
 */
export type Group = {
  name: string;
  course: Course["_id"] | Course;
  participants: (Enrollment["_id"] | Enrollment)[];
  isDeleted?: boolean;
  _id: mongoose.Types.ObjectId;
  createdAt?: Date;
  updatedAt?: Date;
};

/**
 * Lean version of GroupDocument (type alias of `Group`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Group } from "../models"
 * import { GroupObject } from "../interfaces/mongoose.gen.ts"
 *
 * const groupObject: GroupObject = group.toObject();
 * ```
 */
export type GroupObject = Group;

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type GroupQuery = mongoose.Query<any, GroupDocument, GroupQueries> &
  GroupQueries;

/**
 * Mongoose Query helper types
 *
 * This type represents `GroupSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type GroupQueries = {
  paginate: (this: GroupQuery, ...args: any[]) => GroupQuery;
};

export type GroupMethods = {
  softDelete: (this: GroupDocument, ...args: any[]) => any;
  restore: (this: GroupDocument, ...args: any[]) => any;
};

export type GroupStatics = {
  paginate: (this: GroupModel, ...args: any[]) => any;
  paginateSubDocs: (this: GroupModel, ...args: any[]) => any;
};

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Group = mongoose.model<GroupDocument, GroupModel>("Group", GroupSchema);
 * ```
 */
export type GroupModel = mongoose.Model<GroupDocument, GroupQueries> &
  GroupStatics;

/**
 * Mongoose Schema type
 *
 * Assign this type to new Group schema instances:
 * ```
 * const GroupSchema: GroupSchema = new mongoose.Schema({ ... })
 * ```
 */
export type GroupSchema = mongoose.Schema<
  GroupDocument,
  GroupModel,
  GroupMethods,
  GroupQueries
>;

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Group = mongoose.model<GroupDocument, GroupModel>("Group", GroupSchema);
 * ```
 */
export type GroupDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  GroupQueries
> &
  GroupMethods & {
    name: string;
    course: CourseDocument["_id"] | CourseDocument;
    participants: mongoose.Types.Array<
      EnrollmentDocument["_id"] | EnrollmentDocument
    >;
    isDeleted?: boolean;
    _id: mongoose.Types.ObjectId;
    createdAt?: Date;
    updatedAt?: Date;
  };

/**
 * Lean version of ModuleResourceDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `ModuleDocument.toObject()`.
 * ```
 * const moduleObject = module.toObject();
 * ```
 */
export type ModuleResource = {
  resource: Resource["_id"] | Resource;
  order: number;
  isRequired: boolean;
  _id: mongoose.Types.ObjectId;
};

/**
 * Lean version of ModuleDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `ModuleDocument.toObject()`. To avoid conflicts with model names, use the type alias `ModuleObject`.
 * ```
 * const moduleObject = module.toObject();
 * ```
 */
export type Module = {
  name: string;
  resources: ModuleResource[];
  isDeleted?: boolean;
  _id: mongoose.Types.ObjectId;
  createdAt?: Date;
  updatedAt?: Date;
};

/**
 * Lean version of ModuleDocument (type alias of `Module`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Module } from "../models"
 * import { ModuleObject } from "../interfaces/mongoose.gen.ts"
 *
 * const moduleObject: ModuleObject = module.toObject();
 * ```
 */
export type ModuleObject = Module;

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type ModuleQuery = mongoose.Query<any, ModuleDocument, ModuleQueries> &
  ModuleQueries;

/**
 * Mongoose Query helper types
 *
 * This type represents `ModuleSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type ModuleQueries = {
  paginate: (this: ModuleQuery, ...args: any[]) => ModuleQuery;
};

export type ModuleMethods = {
  softDelete: (this: ModuleDocument, ...args: any[]) => any;
  restore: (this: ModuleDocument, ...args: any[]) => any;
};

export type ModuleStatics = {
  paginate: (this: ModuleModel, ...args: any[]) => any;
  paginateSubDocs: (this: ModuleModel, ...args: any[]) => any;
};

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Module = mongoose.model<ModuleDocument, ModuleModel>("Module", ModuleSchema);
 * ```
 */
export type ModuleModel = mongoose.Model<ModuleDocument, ModuleQueries> &
  ModuleStatics;

/**
 * Mongoose Schema type
 *
 * Assign this type to new Module schema instances:
 * ```
 * const ModuleSchema: ModuleSchema = new mongoose.Schema({ ... })
 * ```
 */
export type ModuleSchema = mongoose.Schema<
  ModuleDocument,
  ModuleModel,
  ModuleMethods,
  ModuleQueries
>;

/**
 * Mongoose Subdocument type
 *
 * Type of `ModuleDocument["resources"]` element.
 */
export type ModuleResourceDocument =
  mongoose.Types.Subdocument<mongoose.Types.ObjectId> & {
    resource: ResourceDocument["_id"] | ResourceDocument;
    order: number;
    isRequired: boolean;
    _id: mongoose.Types.ObjectId;
  };

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Module = mongoose.model<ModuleDocument, ModuleModel>("Module", ModuleSchema);
 * ```
 */
export type ModuleDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  ModuleQueries
> &
  ModuleMethods & {
    name: string;
    resources: mongoose.Types.DocumentArray<ModuleResourceDocument>;
    isDeleted?: boolean;
    _id: mongoose.Types.ObjectId;
    createdAt?: Date;
    updatedAt?: Date;
  };

/**
 * Lean version of QuestionMediaDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `QuestionDocument.toObject()`.
 * ```
 * const questionObject = question.toObject();
 * ```
 */
export type QuestionMedia = {
  kind: "image" | "video";
  url?: string;
  _id: mongoose.Types.ObjectId;
};

/**
 * Lean version of QuestionDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `QuestionDocument.toObject()`. To avoid conflicts with model names, use the type alias `QuestionObject`.
 * ```
 * const questionObject = question.toObject();
 * ```
 */
export type Question = {
  text?: string;
  media: QuestionMedia[];
  answers: string[];
  correctAnswers: string[];
  isMultichoice: boolean;
  isDeleted?: boolean;
  _id: mongoose.Types.ObjectId;
  createdAt?: Date;
  updatedAt?: Date;
};

/**
 * Lean version of QuestionDocument (type alias of `Question`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Question } from "../models"
 * import { QuestionObject } from "../interfaces/mongoose.gen.ts"
 *
 * const questionObject: QuestionObject = question.toObject();
 * ```
 */
export type QuestionObject = Question;

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type QuestionQuery = mongoose.Query<
  any,
  QuestionDocument,
  QuestionQueries
> &
  QuestionQueries;

/**
 * Mongoose Query helper types
 *
 * This type represents `QuestionSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type QuestionQueries = {
  paginate: (this: QuestionQuery, ...args: any[]) => QuestionQuery;
};

export type QuestionMethods = {
  softDelete: (this: QuestionDocument, ...args: any[]) => any;
  restore: (this: QuestionDocument, ...args: any[]) => any;
};

export type QuestionStatics = {
  paginate: (this: QuestionModel, ...args: any[]) => any;
  paginateSubDocs: (this: QuestionModel, ...args: any[]) => any;
};

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Question = mongoose.model<QuestionDocument, QuestionModel>("Question", QuestionSchema);
 * ```
 */
export type QuestionModel = mongoose.Model<QuestionDocument, QuestionQueries> &
  QuestionStatics;

/**
 * Mongoose Schema type
 *
 * Assign this type to new Question schema instances:
 * ```
 * const QuestionSchema: QuestionSchema = new mongoose.Schema({ ... })
 * ```
 */
export type QuestionSchema = mongoose.Schema<
  QuestionDocument,
  QuestionModel,
  QuestionMethods,
  QuestionQueries
>;

/**
 * Mongoose Subdocument type
 *
 * Type of `QuestionDocument["media"]` element.
 */
export type QuestionMediaDocument =
  mongoose.Types.Subdocument<mongoose.Types.ObjectId> & {
    kind: "image" | "video";
    url?: string;
    _id: mongoose.Types.ObjectId;
  };

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Question = mongoose.model<QuestionDocument, QuestionModel>("Question", QuestionSchema);
 * ```
 */
export type QuestionDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  QuestionQueries
> &
  QuestionMethods & {
    text?: string;
    media: mongoose.Types.DocumentArray<QuestionMediaDocument>;
    answers: mongoose.Types.Array<string>;
    correctAnswers: mongoose.Types.Array<string>;
    isMultichoice: boolean;
    isDeleted?: boolean;
    _id: mongoose.Types.ObjectId;
    createdAt?: Date;
    updatedAt?: Date;
  };

/**
 * Lean version of ResourceDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `ResourceDocument.toObject()`. To avoid conflicts with model names, use the type alias `ResourceObject`.
 * ```
 * const resourceObject = resource.toObject();
 * ```
 */
export type Resource = {
  name: string;
  isDeleted?: boolean;
  _id: mongoose.Types.ObjectId;
  createdAt?: Date;
  updatedAt?: Date;
  type?: string;
};

/**
 * Lean version of ResourceDocument (type alias of `Resource`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Resource } from "../models"
 * import { ResourceObject } from "../interfaces/mongoose.gen.ts"
 *
 * const resourceObject: ResourceObject = resource.toObject();
 * ```
 */
export type ResourceObject = Resource;

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type ResourceQuery = mongoose.Query<
  any,
  ResourceDocument,
  ResourceQueries
> &
  ResourceQueries;

/**
 * Mongoose Query helper types
 *
 * This type represents `ResourceSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type ResourceQueries = {
  paginate: (this: ResourceQuery, ...args: any[]) => ResourceQuery;
};

export type ResourceMethods = {
  softDelete: (this: ResourceDocument, ...args: any[]) => any;
  restore: (this: ResourceDocument, ...args: any[]) => any;
};

export type ResourceStatics = {
  paginate: (this: ResourceModel, ...args: any[]) => any;
  paginateSubDocs: (this: ResourceModel, ...args: any[]) => any;
};

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Resource = mongoose.model<ResourceDocument, ResourceModel>("Resource", ResourceSchema);
 * ```
 */
export type ResourceModel = mongoose.Model<ResourceDocument, ResourceQueries> &
  ResourceStatics;

/**
 * Mongoose Schema type
 *
 * Assign this type to new Resource schema instances:
 * ```
 * const ResourceSchema: ResourceSchema = new mongoose.Schema({ ... })
 * ```
 */
export type ResourceSchema = mongoose.Schema<
  ResourceDocument,
  ResourceModel,
  ResourceMethods,
  ResourceQueries
>;

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Resource = mongoose.model<ResourceDocument, ResourceModel>("Resource", ResourceSchema);
 * ```
 */
export type ResourceDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  ResourceQueries
> &
  ResourceMethods & {
    name: string;
    isDeleted?: boolean;
    _id: mongoose.Types.ObjectId;
    createdAt?: Date;
    updatedAt?: Date;
    type?: string;
  };

/**
 * Lean version of TestResourceDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `TestResourceDocument.toObject()`. To avoid conflicts with model names, use the type alias `TestResourceObject`.
 * ```
 * const testresourceObject = testresource.toObject();
 * ```
 */
export type TestResource = {
  name: string;
  isDeleted?: boolean;
  _id: mongoose.Types.ObjectId;
  createdAt?: Date;
  updatedAt?: Date;
  type?: string;
  questions: (Question["_id"] | Question)[];
  passRate?: number;
  showCorrectAnswers?: boolean;
};

/**
 * Lean version of TestResourceDocument (type alias of `TestResource`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { TestResource } from "../models"
 * import { TestResourceObject } from "../interfaces/mongoose.gen.ts"
 *
 * const testresourceObject: TestResourceObject = testresource.toObject();
 * ```
 */
export type TestResourceObject = TestResource;

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type TestResourceQuery = mongoose.Query<
  any,
  TestResourceDocument,
  TestResourceQueries
> &
  TestResourceQueries;

/**
 * Mongoose Query helper types
 *
 * This type represents `TestResourceSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type TestResourceQueries = {
  paginate: (this: TestResourceQuery, ...args: any[]) => TestResourceQuery;
};

export type TestResourceMethods = {
  softDelete: (this: TestResourceDocument, ...args: any[]) => any;
  restore: (this: TestResourceDocument, ...args: any[]) => any;
};

export type TestResourceStatics = {
  paginate: (this: TestResourceModel, ...args: any[]) => any;
  paginateSubDocs: (this: TestResourceModel, ...args: any[]) => any;
};

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const TestResource = mongoose.model<TestResourceDocument, TestResourceModel>("TestResource", TestResourceSchema);
 * ```
 */
export type TestResourceModel = mongoose.Model<
  TestResourceDocument,
  TestResourceQueries
> &
  TestResourceStatics;

/**
 * Mongoose Schema type
 *
 * Assign this type to new TestResource schema instances:
 * ```
 * const TestResourceSchema: TestResourceSchema = new mongoose.Schema({ ... })
 * ```
 */
export type TestResourceSchema = mongoose.Schema<
  TestResourceDocument,
  TestResourceModel,
  TestResourceMethods,
  TestResourceQueries
>;

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const TestResource = mongoose.model<TestResourceDocument, TestResourceModel>("TestResource", TestResourceSchema);
 * ```
 */
export type TestResourceDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  TestResourceQueries
> &
  TestResourceMethods & {
    name: string;
    isDeleted?: boolean;
    _id: mongoose.Types.ObjectId;
    createdAt?: Date;
    updatedAt?: Date;
    type?: string;
    questions: mongoose.Types.Array<QuestionDocument["_id"] | QuestionDocument>;
    passRate?: number;
    showCorrectAnswers?: boolean;
  };

/**
 * Lean version of LectureResourceMediaDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `LectureResourceDocument.toObject()`.
 * ```
 * const lectureresourceObject = lectureresource.toObject();
 * ```
 */
export type LectureResourceMedia = {
  kind: "image" | "video";
  url: string;
  _id: mongoose.Types.ObjectId;
};

/**
 * Lean version of LectureResourceDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `LectureResourceDocument.toObject()`. To avoid conflicts with model names, use the type alias `LectureResourceObject`.
 * ```
 * const lectureresourceObject = lectureresource.toObject();
 * ```
 */
export type LectureResource = {
  name: string;
  isDeleted?: boolean;
  _id: mongoose.Types.ObjectId;
  createdAt?: Date;
  updatedAt?: Date;
  type?: string;
  text?: string;
  media: LectureResourceMedia[];
};

/**
 * Lean version of LectureResourceDocument (type alias of `LectureResource`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { LectureResource } from "../models"
 * import { LectureResourceObject } from "../interfaces/mongoose.gen.ts"
 *
 * const lectureresourceObject: LectureResourceObject = lectureresource.toObject();
 * ```
 */
export type LectureResourceObject = LectureResource;

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type LectureResourceQuery = mongoose.Query<
  any,
  LectureResourceDocument,
  LectureResourceQueries
> &
  LectureResourceQueries;

/**
 * Mongoose Query helper types
 *
 * This type represents `LectureResourceSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type LectureResourceQueries = {
  paginate: (
    this: LectureResourceQuery,
    ...args: any[]
  ) => LectureResourceQuery;
};

export type LectureResourceMethods = {
  softDelete: (this: LectureResourceDocument, ...args: any[]) => any;
  restore: (this: LectureResourceDocument, ...args: any[]) => any;
};

export type LectureResourceStatics = {
  paginate: (this: LectureResourceModel, ...args: any[]) => any;
  paginateSubDocs: (this: LectureResourceModel, ...args: any[]) => any;
};

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const LectureResource = mongoose.model<LectureResourceDocument, LectureResourceModel>("LectureResource", LectureResourceSchema);
 * ```
 */
export type LectureResourceModel = mongoose.Model<
  LectureResourceDocument,
  LectureResourceQueries
> &
  LectureResourceStatics;

/**
 * Mongoose Schema type
 *
 * Assign this type to new LectureResource schema instances:
 * ```
 * const LectureResourceSchema: LectureResourceSchema = new mongoose.Schema({ ... })
 * ```
 */
export type LectureResourceSchema = mongoose.Schema<
  LectureResourceDocument,
  LectureResourceModel,
  LectureResourceMethods,
  LectureResourceQueries
>;

/**
 * Mongoose Subdocument type
 *
 * Type of `LectureResourceDocument["media"]` element.
 */
export type LectureResourceMediaDocument =
  mongoose.Types.Subdocument<mongoose.Types.ObjectId> & {
    kind: "image" | "video";
    url: string;
    _id: mongoose.Types.ObjectId;
  };

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const LectureResource = mongoose.model<LectureResourceDocument, LectureResourceModel>("LectureResource", LectureResourceSchema);
 * ```
 */
export type LectureResourceDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  LectureResourceQueries
> &
  LectureResourceMethods & {
    name: string;
    isDeleted?: boolean;
    _id: mongoose.Types.ObjectId;
    createdAt?: Date;
    updatedAt?: Date;
    type?: string;
    text?: string;
    media: mongoose.Types.DocumentArray<LectureResourceMediaDocument>;
  };

/**
 * Lean version of VideoResourceDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `VideoResourceDocument.toObject()`. To avoid conflicts with model names, use the type alias `VideoResourceObject`.
 * ```
 * const videoresourceObject = videoresource.toObject();
 * ```
 */
export type VideoResource = {
  name: string;
  isDeleted?: boolean;
  _id: mongoose.Types.ObjectId;
  createdAt?: Date;
  updatedAt?: Date;
  type?: string;
  text?: string;
  url: string;
};

/**
 * Lean version of VideoResourceDocument (type alias of `VideoResource`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { VideoResource } from "../models"
 * import { VideoResourceObject } from "../interfaces/mongoose.gen.ts"
 *
 * const videoresourceObject: VideoResourceObject = videoresource.toObject();
 * ```
 */
export type VideoResourceObject = VideoResource;

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type VideoResourceQuery = mongoose.Query<
  any,
  VideoResourceDocument,
  VideoResourceQueries
> &
  VideoResourceQueries;

/**
 * Mongoose Query helper types
 *
 * This type represents `VideoResourceSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type VideoResourceQueries = {
  paginate: (this: VideoResourceQuery, ...args: any[]) => VideoResourceQuery;
};

export type VideoResourceMethods = {
  softDelete: (this: VideoResourceDocument, ...args: any[]) => any;
  restore: (this: VideoResourceDocument, ...args: any[]) => any;
};

export type VideoResourceStatics = {
  paginate: (this: VideoResourceModel, ...args: any[]) => any;
  paginateSubDocs: (this: VideoResourceModel, ...args: any[]) => any;
};

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const VideoResource = mongoose.model<VideoResourceDocument, VideoResourceModel>("VideoResource", VideoResourceSchema);
 * ```
 */
export type VideoResourceModel = mongoose.Model<
  VideoResourceDocument,
  VideoResourceQueries
> &
  VideoResourceStatics;

/**
 * Mongoose Schema type
 *
 * Assign this type to new VideoResource schema instances:
 * ```
 * const VideoResourceSchema: VideoResourceSchema = new mongoose.Schema({ ... })
 * ```
 */
export type VideoResourceSchema = mongoose.Schema<
  VideoResourceDocument,
  VideoResourceModel,
  VideoResourceMethods,
  VideoResourceQueries
>;

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const VideoResource = mongoose.model<VideoResourceDocument, VideoResourceModel>("VideoResource", VideoResourceSchema);
 * ```
 */
export type VideoResourceDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  VideoResourceQueries
> &
  VideoResourceMethods & {
    name: string;
    isDeleted?: boolean;
    _id: mongoose.Types.ObjectId;
    createdAt?: Date;
    updatedAt?: Date;
    type?: string;
    text?: string;
    url: string;
  };

/**
 * Lean version of RoleDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `RoleDocument.toObject()`. To avoid conflicts with model names, use the type alias `RoleObject`.
 * ```
 * const roleObject = role.toObject();
 * ```
 */
export type Role = {
  name: string;
  isPublic: boolean;
  availableTo: (Company["_id"] | Company)[];
  isDeleted?: boolean;
  _id: mongoose.Types.ObjectId;
  createdAt?: Date;
  updatedAt?: Date;
};

/**
 * Lean version of RoleDocument (type alias of `Role`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { Role } from "../models"
 * import { RoleObject } from "../interfaces/mongoose.gen.ts"
 *
 * const roleObject: RoleObject = role.toObject();
 * ```
 */
export type RoleObject = Role;

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type RoleQuery = mongoose.Query<any, RoleDocument, RoleQueries> &
  RoleQueries;

/**
 * Mongoose Query helper types
 *
 * This type represents `RoleSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type RoleQueries = {
  paginate: (this: RoleQuery, ...args: any[]) => RoleQuery;
};

export type RoleMethods = {
  softDelete: (this: RoleDocument, ...args: any[]) => any;
  restore: (this: RoleDocument, ...args: any[]) => any;
};

export type RoleStatics = {
  paginate: (this: RoleModel, ...args: any[]) => any;
  paginateSubDocs: (this: RoleModel, ...args: any[]) => any;
};

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Role = mongoose.model<RoleDocument, RoleModel>("Role", RoleSchema);
 * ```
 */
export type RoleModel = mongoose.Model<RoleDocument, RoleQueries> & RoleStatics;

/**
 * Mongoose Schema type
 *
 * Assign this type to new Role schema instances:
 * ```
 * const RoleSchema: RoleSchema = new mongoose.Schema({ ... })
 * ```
 */
export type RoleSchema = mongoose.Schema<
  RoleDocument,
  RoleModel,
  RoleMethods,
  RoleQueries
>;

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Role = mongoose.model<RoleDocument, RoleModel>("Role", RoleSchema);
 * ```
 */
export type RoleDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  RoleQueries
> &
  RoleMethods & {
    name: string;
    isPublic: boolean;
    availableTo: mongoose.Types.Array<CompanyDocument["_id"] | CompanyDocument>;
    isDeleted?: boolean;
    _id: mongoose.Types.ObjectId;
    createdAt?: Date;
    updatedAt?: Date;
  };

/**
 * Lean version of UserDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `UserDocument.toObject()`. To avoid conflicts with model names, use the type alias `UserObject`.
 * ```
 * const userObject = user.toObject();
 * ```
 */
export type User = {
  companies: (Company["_id"] | Company)[];
  firstName: string;
  lastName: string;
  email: string;
  password: string;
  isDeleted?: boolean;
  _id: mongoose.Types.ObjectId;
  createdAt?: Date;
  updatedAt?: Date;
};

/**
 * Lean version of UserDocument (type alias of `User`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { User } from "../models"
 * import { UserObject } from "../interfaces/mongoose.gen.ts"
 *
 * const userObject: UserObject = user.toObject();
 * ```
 */
export type UserObject = User;

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type UserQuery = mongoose.Query<any, UserDocument, UserQueries> &
  UserQueries;

/**
 * Mongoose Query helper types
 *
 * This type represents `UserSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type UserQueries = {
  paginate: (this: UserQuery, ...args: any[]) => UserQuery;
};

export type UserMethods = {
  softDelete: (this: UserDocument, ...args: any[]) => any;
  restore: (this: UserDocument, ...args: any[]) => any;
};

export type UserStatics = {
  paginate: (this: UserModel, ...args: any[]) => any;
  paginateSubDocs: (this: UserModel, ...args: any[]) => any;
};

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const User = mongoose.model<UserDocument, UserModel>("User", UserSchema);
 * ```
 */
export type UserModel = mongoose.Model<UserDocument, UserQueries> & UserStatics;

/**
 * Mongoose Schema type
 *
 * Assign this type to new User schema instances:
 * ```
 * const UserSchema: UserSchema = new mongoose.Schema({ ... })
 * ```
 */
export type UserSchema = mongoose.Schema<
  UserDocument,
  UserModel,
  UserMethods,
  UserQueries
>;

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const User = mongoose.model<UserDocument, UserModel>("User", UserSchema);
 * ```
 */
export type UserDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  UserQueries
> &
  UserMethods & {
    companies: mongoose.Types.Array<CompanyDocument["_id"] | CompanyDocument>;
    firstName: string;
    lastName: string;
    email: string;
    password: string;
    isDeleted?: boolean;
    _id: mongoose.Types.ObjectId;
    createdAt?: Date;
    updatedAt?: Date;
  };

/**
 * Check if a property on a document is populated:
 * ```
 * import { IsPopulated } from "../interfaces/mongoose.gen.ts"
 *
 * if (IsPopulated<UserDocument["bestFriend"]>) { ... }
 * ```
 */
export function IsPopulated<T>(doc: T | mongoose.Types.ObjectId): doc is T {
  return doc instanceof mongoose.Document;
}

/**
 * Helper type used by `PopulatedDocument`. Returns the parent property of a string
 * representing a nested property (i.e. `friend.user` -> `friend`)
 */
type ParentProperty<T> = T extends `${infer P}.${string}` ? P : never;

/**
 * Helper type used by `PopulatedDocument`. Returns the child property of a string
 * representing a nested property (i.e. `friend.user` -> `user`).
 */
type ChildProperty<T> = T extends `${string}.${infer C}` ? C : never;

/**
 * Helper type used by `PopulatedDocument`. Removes the `ObjectId` from the general union type generated
 * for ref documents (i.e. `mongoose.Types.ObjectId | UserDocument` -> `UserDocument`)
 */
type PopulatedProperty<Root, T extends keyof Root> = Omit<Root, T> & {
  [ref in T]: Root[T] extends mongoose.Types.Array<infer U>
    ? mongoose.Types.Array<Exclude<U, mongoose.Types.ObjectId>>
    : Exclude<Root[T], mongoose.Types.ObjectId>;
};

/**
 * Populate properties on a document type:
 * ```
 * import { PopulatedDocument } from "../interfaces/mongoose.gen.ts"
 *
 * function example(user: PopulatedDocument<UserDocument, "bestFriend">) {
 *   console.log(user.bestFriend._id) // typescript knows this is populated
 * }
 * ```
 */
export type PopulatedDocument<DocType, T> = T extends keyof DocType
  ? PopulatedProperty<DocType, T>
  : ParentProperty<T> extends keyof DocType
  ? Omit<DocType, ParentProperty<T>> & {
      [ref in ParentProperty<T>]: DocType[ParentProperty<T>] extends mongoose.Types.Array<
        infer U
      >
        ? mongoose.Types.Array<
            ChildProperty<T> extends keyof U
              ? PopulatedProperty<U, ChildProperty<T>>
              : PopulatedDocument<U, ChildProperty<T>>
          >
        : ChildProperty<T> extends keyof DocType[ParentProperty<T>]
        ? PopulatedProperty<DocType[ParentProperty<T>], ChildProperty<T>>
        : PopulatedDocument<DocType[ParentProperty<T>], ChildProperty<T>>;
    }
  : DocType;

/**
 * Helper types used by the populate overloads
 */
type Unarray<T> = T extends Array<infer U> ? U : T;
type Modify<T, R> = Omit<T, keyof R> & R;

/**
 * Augment mongoose with Query.populate overloads
 */
declare module "mongoose" {
  interface Query<ResultType, DocType, THelpers = {}> {
    populate<T extends string>(
      path: T,
      select?: string | any,
      model?: string | Model<any, THelpers>,
      match?: any
    ): Query<
      ResultType extends Array<DocType>
        ? Array<PopulatedDocument<Unarray<ResultType>, T>>
        : ResultType extends DocType
        ? PopulatedDocument<Unarray<ResultType>, T>
        : ResultType,
      DocType,
      THelpers
    > &
      THelpers;

    populate<T extends string>(
      options: Modify<PopulateOptions, { path: T }> | Array<PopulateOptions>
    ): Query<
      ResultType extends Array<DocType>
        ? Array<PopulatedDocument<Unarray<ResultType>, T>>
        : ResultType extends DocType
        ? PopulatedDocument<Unarray<ResultType>, T>
        : ResultType,
      DocType,
      THelpers
    > &
      THelpers;
  }
}
